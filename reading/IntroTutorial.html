<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<title>Web-Based Simulation with OESjs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="This article shows how to create, and run, a discrete event simulation model with the JavaScript-based simulation framework OESjs available on Sim4edu.com, which implements the Object-Event Simulation (OES) paradigm, representing a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling. In OES, a model normally defines various types of objects and events, but OES also supports models without explicit events, using fixed-increment time progression corresponding to implicit time events, which is a popular approach in social science simulation."/>
<link href="IntroTutorial_files/ebook.css" rel="stylesheet" type="text/css" />
<style>
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
table.expStatistics tbody td {
    text-align: right;
}</style></head>
<body><section class="role-book" id="IntroTutorial"><div class="role-book-title-div"><h1 class="role-book-title">Web-Based Simulation with OESjs</h1><div class="role-content" id="IntroTutorial-content-1"><div id="IntroTutorial-content-1__subtitle">How to create and run simulations with the JavaScript-based simulation framework OESjs available on sim4edu.com</div><div id="IntroTutorial-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Thanks to Luis Gustavo Nardin and Jakub Lelo for valuable feedback that helped to improve this tutorial.</p><p>Copyright Â© 2017-19 Gerd Wagner</p><p>Published 2019-04-11</p><h2>Abstract</h2><p>This article shows how to create, and run, a <em>simulation model</em> with the JavaScript-based simulation framework OESjs available on <a href="https://sim4edu.com/">Sim4edu.com</a>. OESjs implements the <em>Object Event Simulation (<a href="https://sim4edu.com/oes">OES</a>)</em> paradigm, representing a general <em>Discrete Event Simulation</em> approach based on object-oriented modeling and event scheduling. In OES, a model normally defines various types of objects and events, but OES also supports models without explicit events, using fixed-increment time progression corresponding to implicit time events (&quot;ticks&quot;), which is a popular approach in social science simulation.</p><p>This tutorial is also available in the following formats: <a href="IntroTutorial.epub">EPUB</a> <a href="IntroTutorial.pdf">PDF</a></p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index"><span class="role-label"><span class="role-number">1</span>. </span>Introduction to Object Event Modeling</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#CM"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#DesM"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-2"><span class="role-label"><span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimTime"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimModels"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimScenarios"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimConfigurations"><span class="role-label"><span class="role-number">2.4</span>. </span>Simulation Configurations</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimStatistics"><span class="role-label"><span class="role-number">2.5</span>. </span>Statistics</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimExperiments"><span class="role-label"><span class="role-number">2.6</span>. </span>Simulation Experiments</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Animation"><span class="role-label"><span class="role-number">2.7</span>. </span>Animation</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimProgramming"><span class="role-label"><span class="role-number">2.8</span>. </span>Simulation Programming with OESjs</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label"><span class="role-number">1-1</span>. </span>An information design model for ServiceDesk-0</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label"><span class="role-number">1-2</span>. </span>An information design model for ServiceDesk-1</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1></section></div><section class="role-chapter" id="index"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling</h1><p>Simulation is used widely today: in many scientific disciplines for investigating specific research questions, in engineering for testing the performance of designs, in education for providing interactive learning experiences, and in entertainment for making games.</p><p>For simulating a dynamic system one can model it in terms of</p><ol><li>the types of objects it is composed of,</li><li>the types of events that are responsible for its dynamics,</li><li>the discrete state changes of objects caused by the occurrence of an event of some type,</li><li>the follow-up events caused by the occurrence of an event of some type,</li><li>the continuous state changes of objects (described with the help of differential equations).</li></ol><p>Many dynamic systems are examples of <b>discrete event systems</b><a class="role-index-anchor" id="index__I__1"></a> (or discrete dynamic systems)<a class="role-index-anchor" id="index__I__2"></a>, which consist of:</p><ul><li><b>objects</b> (of various types) whose states may be changed by</li><li><b>events</b> (of various types) occurring at some point in time.</li></ul><p>This means that in order to model a discrete event system, we have to</p><ol><li>describe its <b>object types</b> and <b>event types</b> (in an information model);</li><li>specify, for any event type, the <b>state changes</b> of objects and the <b>follow-up events</b> caused by the occurrence of an event of that type (in a process model).</li></ol><section class="role-section1" id="CM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model</h2><figure class="right"><img alt="" src="IntroTutorial_files/service-desk.svg" width="200" /></figure><p>Let's look at an example. We model a system of one or more service desks, each of them having its own queue, as a discrete event system:</p><ul><li>Customers arrive at a service desk at random times.</li><li>If there is no other customer in front of them, and the service desk is available, they are served immediately, otherwise they have to queue up in a waiting line.</li><li>The duration of services varies, depending on the individual case.</li><li>When a service is completed, the customer departs and the next customer is served, if there is still any customer in the queue.</li></ul><p>The potentially relevant <b>object types</b> of the problem domain are:</p><ul><li>customers,</li><li>service desks,</li><li>waiting lines,</li><li>service clerks, if the service is performed by (one or more) clerks.</li></ul><p>The potentially relevant <b>event types</b> are:</p><ul><li>customer arrivals,</li><li>service starts,</li><li>service terminations,</li><li>customer departures.</li></ul></section><section class="role-section1" id="DesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</h2><p>When making a simulation model, the right degree of abstraction depends on the purpose of the model. But abstracting away from too many things may make a model too unnatural and not sufficiently generic, implying that it cannot be easily extended to model additional features (such as more than one service desk).</p><p>In our example, the purpose of the simulation model is to compute the <em>maximum queue length</em> and possibly also the <em>service utilization</em>. So, we may abstract away from the following object types:</p><ul><li><em>customers</em>: we don't need any information about individual customers.</li><li><em>waiting lines</em>: we don't need to know who is next, it's sufficient to know the length of the queue.</li><li><em>service clerks</em>: we don't need any information about the service clerk(s).</li></ul><p>Notice that, for simplicity, we consider the customer that is currently being served to be part of the queue. In this way, in the simulation program, we can check if the service desk is busy by testing if the length of the queue is greater than 0. In fact, for being able to compute the service utilization and the maximum queue length, the queue length is the only relevant state variable.</p><p>State variables can be modeled in the simple form of <em>global variables</em> or in the form of <em>attributes</em> of suitable object types. Consequently, the simplest model we can make for the given problem, called <em>ServiceDesk-0</em>, has only one global variable: <i>queueLength</i>. But, as an alternative, more explicit, model, called <em>ServiceDesk-1</em>, we will also model the system state in terms of (one or more) <i>ServiceDesk</i> objects having only one property: <i>queueLength</i>. As opposed to the simpler model defining <i>queueLength</i> as a global variable, this model allows defining simulation scenarios with two or more service desks operating simultaneously.</p><p>We also look for opportunities to simplify our event model by dropping event types that are not needed, e.g., because their events temporally coincide with events of another type. This is the case with <em>service terminations</em> and <i>customer departure</i> events. Consequently, we can drop the event type <em>service terminations</em>.</p><p>There are two situations when a new service can be started: either when the waiting line is empty and a new customer arrives, or when the waiting line is not empty and a service terminates. Therefore, any <em>service start</em> event immediately follows either a <i>customer arrival</i> or a <i>customer departure</i> event, and we may abstract away from <em>service start</em> events and drop the corresponding event type from the design model.</p><p>So we only need to consider <i>customer arrival</i> and <i>customer departure</i> events, modeled with the two event types <i>CustomerArrival</i> and <i>CustomerDeparture</i>.</p><p>The event type <i>CustomerArrival</i> is an example of a type of <b>exogenous</b> events,<a class="role-index-anchor" id="DesM__I__3"></a> which are not caused by any causal regularity of the system under investigation and, therefore, have to be modeled with a <b>recurrence</b><a class="role-index-anchor" id="DesM__I__4"></a> function that allows to compute the time of the next occurrence of an event of that type. In OES, exogenous event types are a built-in concept such that an OES simulator takes care of creating the next exogenous event whenever an event of that type is processed. This mechanism makes sure that there is a continuous stream of exogenous events throughout a simulation run.</p><p>We also have to model the random variations of two variables: (1) the recurrence of (that is, the time in-between two) customer arrival events and (2) the service duration. In a class model, such random variables<a class="role-index-anchor" id="DesM__I__5"></a> can be defined as special class-level (&quot;static&quot;) operations, with a stereotype Â«rvÂ», in the class to which they belong, as shown in the diagrams below.</p><p>We model the recurrence of customer arrival events as a discrete random variable with a uniform distribution between 1 and 6 minutes, which we express in the class diagram of the information design model by appending the symbolic expression <i>U{1-6}</i> within curly braces to the operation declaration, following the UML syntax for property/method modifiers.</p><p>We model the service duration random variable with an empirical distribution of 2 minutes with probability 0.3, 3 minutes with probability 0.5 and 4 minutes with probability 0.2, using the symbolic expression <i>Emp{2:0.3, 3:0.5, 4:0.2}</i>.</p><p>Computationally, object types and event types correspond to classes, either of an object-oriented information model, such as a UML class diagram, or of a computer program written in an object-oriented programming language, such as Java or JavaScript.</p><section><h4>1.2.1.Â ServiceDesk-0: Modeling <i>queueLength</i> as a global variable</h4><p>As discussed above, the simplest model for the service desk problem with maximum queue length statistics (available in the Sim4edu library as <a href="https://sim4edu.com/sims/14" target="_top">ServiceDesk-0</a>) has only one global variable: <i>queueLength</i>, a non-negative integer, and a global function for computing the random service duration, but no object type.</p><p>An information model for ServiceDesk-0 consists of a special class for defining model variables and functions, and two classes for defining the event types <i>CustomerArrival</i> and <i>CustomerDeparture</i>, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for ServiceDesk-0</a>.</p><figure id="DesM__figServiceDesk0"><figcaption><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for ServiceDesk-0</figcaption><div><img alt="???" src="IntroTutorial_files/IDM0.svg" width="360" /></div></figure><p>In addition to an information model, which captures the system's state structure, we also need to make a process model that captures the dynamics of the service desk system. The dynamics of a system consists of events triggering state changes and follow-up events. A process model can be expressed with the help of event rules, which define what happens when an event (of a certain type) occurs, or, more specifically, which state changes and which follow-up events are caused by an event of that type.</p><p>Event rules can be expressed with the help of pseudo-code or in process diagrams, or in a simulation or programming language. The following table shows the two event rules defining the transition logic of a service desk system, expressed in pseudo-code.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>CustomerArrival @ t</p></td><td><pre>INCREMENT queueLength
IF queueLength = 1 THEN
  sTime := serviceDuration()
  SCHEDULE CustomerDeparture @ (t + sTime)
</pre></td></tr><tr><td><p>CustomerDeparture @ t</p></td><td><pre>DECREMENT queueLength
IF queueLength &gt; 0 THEN
  sTime := serviceDuration()
  SCHEDULE CustomerDeparture @ (t + sTime)</pre></td></tr></tbody></table></section> <section><h4>1.2.2.Â ServiceDesk-1: Modeling <i>queueLength</i> as an attribute</h4><p>In our extended model (<a href="https://sim4edu.com/sims/1" target="_top">ServiceDesk-1</a>) we represent the state variable <i>queueLength</i> as an attribute of an object type <i>ServiceDesk</i>. This results in a model with three classes, the object class <i>ServiceDesk</i> with an attribute <i>queueLength</i>, and the event classes <i>CustomerArrival</i> and <i>CustomerDeparture</i>, both with a reference property <i>serviceDesk</i> for referencing the service desk at which an event occurs. When we also want to compute the service utilization statistics, we need to add an attribute <i>serviceTime</i> to the <i>CustomerDeparture</i> class for being able to update the service utilization statistics when a customer departs.</p><p>Both event types, <i>CustomerArrival</i> and <i>CustomerDeparture</i>, now have a many-to-one association with the object type <i>ServiceDesk</i>. This expresses the fact that any such event occurs at a particular service desk, which participates in the event. This association is implemented in the form of a reference property <i>serviceDesk</i> in each of the two event types, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label">Figure <span class="role-number">1-2</span>. </span>An information design model for ServiceDesk-1</a>.</p><figure id="DesM__figServiceDesk1"><figcaption><span class="role-label">Figure <span class="role-number">1-2</span>. </span>An information design model for ServiceDesk-1</figcaption><div><img alt="???" src="IntroTutorial_files/IDM1.svg" width="400" /></div></figure><p>In addition to an information model, we need to make a process model, which captures the dynamics of the service desk system consisting of arrival and departure events triggering state changes and follow-up events.</p><p>The following table shows the two event rules, which now account for the fact that both types of events occur at a particular service desk that is referenced by the event expression parameter <i>sd</i>.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>CustomerArrival( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>INCREMENT sd.queueLength
IF sd.queueLength = 1 THEN
  sTime := ServiceDesk.serviceDuration()
  SCHEDULE CustomerDeparture( sTime, sd) @(t + sTime)
</pre></td></tr><tr><td><p>CustomerDeparture( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>DECREMENT sd.queueLength
IF sd.queueLength &gt; 0 THEN
  sTime := ServiceDesk.serviceDuration()
  SCHEDULE CustomerDeparture( sTime, sd) @(t + sTime)</pre></td></tr></tbody></table><p>In the next section, we discuss how to implement this simple model of a service desk system with the OESjs simulation framework.</p></section></section></section><section class="role-chapter" id="index-2"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs</h1><p>The <a href="https://sim4edu.com/" target="_top">Simulation for Education (Sim4edu)</a> project website supports web-based simulation with open source technologies for science and education. It provides technologies, such as simulation libraries, frameworks, and simulators, as well as a collection of simulation examples. One important goal of Sim4edu is to facilitate building state-of-the-art user interfaces for simulations and simulation games without requiring simulation developers to learn all the recent web technologies involved (e.g., HTML5, CSS3, SVG and WebGL).</p><p>The JavaScript-based simulation framework <i>OESjs</i> implements the <i>Object Event Simulation (<a href="https://sim4edu.com/OES" target="_top">OES</a>)</i> paradigm, representing a general <i>Discrete Event Simulation</i> approach based on <i>object-oriented</i> modeling and <i>event scheduling</i>. In OES, a model normally defines various types of objects and events, but OES also supports</p><ol><li><p>models without objects, if they define state variables in the form of global <i>model variables</i>, instead;</p></li><li><p>models without events, if they use pure fixed-increment time progression (by defining an <code>onEachTimeStep</code> procedure and a <code>timeIncrement</code> parameter), instead; such a model can be used </p><ol type="a"><li><p>as a discrete model that abstracts away from explicit events and uses only implicit time events (&quot;ticks&quot;), which is a popular approach in social science simulation, or</p></li><li><p>for modeling continuous state changes (e.g., objects moving in a continuous space).</p></li></ol></li></ol><p>OESjs supports two forms of simulations:</p><ol><li><p>Standalone scenario simulations, which are good for getting a quick impression of a simulation model, e.g., by checking some simple statistics or by observing visualized (or sonified) simulation runs.</p></li><li><p>Simulation experiments, which are defined as a set of simulation scenarios by defining value sets for certain model variables, such that an experiment run consists of a set of scenario runs.</p></li></ol><p>Using a simulation framework like OESjs means that only the model-specific logic has to be coded (in the form of object types, event types, event routines and other functions for model-specific computations), but not the general simulator operations (e.g., time progression and statistics) and the environment handling (e.g., user interfaces for statistics output and visualization).</p><p>The following sections present the basic concepts of the OESjs simulation framework, and show how to implement the service desk models described in the previous section.</p><section class="role-section1" id="SimTime"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</h2><p>A simulation model has an underlying <b><i>time model</i></b>, which can be either <i>discrete time</i>, when setting</p><pre>sim.model.time = &quot;discrete&quot;;</pre><p>or <i>continuous time</i>, when setting</p><pre>sim.model.time = &quot;continuous&quot;;</pre><p>Choosing a discrete time model means that time is measured in steps (with equal durations), and all temporal random variables used in the model need to be discrete (i.e., based on discrete probability distributions). Choosing a continuous time model means that one has to define a <i>simulation time granularity</i>, as explained in the next sub-section.</p><p>In both cases, the underlying simulation <b><i>time unit</i></b> can be either left unspecified (e.g., in the case of an abstract time model), or it can be set to one of the time units &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;, &quot;D&quot;, &quot;W&quot;, &quot;M&quot; or &quot;Y&quot;, as in</p><pre>sim.model.timeUnit = &quot;h&quot;;</pre><p>Typical examples of time models are:</p><ol><li><p>An abstract discrete model of time where time runs in steps without any concrete meaning: </p><pre>sim.model.time = &quot;discrete&quot;;</pre></li><li><p>A concrete discrete model of time in number of days: </p><pre>sim.model.time = &quot;discrete&quot;;
sim.model.timeUnit = &quot;D&quot;;</pre></li><li><p>A concrete continuous model of time in number of seconds: </p><pre>sim.model.time = &quot;continuous&quot;;
sim.model.timeUnit = &quot;s&quot;;</pre></li></ol><section><h4>2.1.1. Time Granularity</h4><p>When a simulation model is based on continuous time, it is possible to control the time granularity (the time delay until the next moment) in one of two ways:</p><ol><li>through simulation time rounding by setting the model parameter <i>timeRoundingDecimalPlaces</i> to a suitable value (e.g., to 2 for obtaining time values like 281.39), which implies a corresponding value of the model parameter <i>nextMomentDeltaT</i>;</li><li>by explicitly setting the model parameter <i>nextMomentDeltaT</i>.</li></ol><p>The model parameter <i>nextMomentDeltaT</i> is used by the simulator for scheduling next events with a minimal delay.</p></section><section><h4>2.1.2. Time Progression</h4><p>An important issue in simulation is the question how the simulation time is advanced by the simulator. The OES paradigm supports <strong>fixed-increment</strong> time progression and <strong>next-event</strong> time progression, and their combination.</p><p>An OESjs model with pure fixed-increment time progression defines an <code>OnEachTimeStep</code> procedure and a <code>timeIncrement</code> parameter, but no event types. Such a model can be used</p><ol><li>for modeling continuous state changes (e.g., objects moving in a continuous space), or</li><li>as a discrete model that abstracts away from explicit events and uses only implicit periodic time events (&quot;ticks&quot;), which is a popular approach in social science simulation.</li></ol><p>A simulation model with pure next-event time progression, representing a classical DES model, defines event types and event rules, but no <code>timeIncrement</code> parameter.</p><p>It is also possible to combine both time progression mechanisms, e.g., in a &quot;hybrid&quot; model that supports both discrete and continuous state changes, or in a social science model based on &quot;ticks&quot; and explicit events.</p></section><section><h4>2.1.3. Real-Time Simulation</h4><p>Real-time simulation means to run an observable simulation model in such a way that the speed of its state changes is close to the speed of the state changes in the simulated real-world system. This is only possible if the simulator is able to run the simulation at least as fast as the real-world system is running. If this is the case, the running simulator can be slowed down to real-time speed. </p><p>Real-time simulation requires fixed-increment time progression by setting the model parameter <i>timeIncrement</i>. In the case of a model with a <i>timeUnit</i> and real-time simulation turned on (by setting the scenario parameter <i>realtimeFactor</i> to 1), the simulator delays each simulation step such that its real duration is equal to its simulation time, which is <i>timeIncrement</i> [timeUnit].</p><p>In the case of a model without a <i>timeUnit</i> (that is, with abstract time), the simulator cannot automatically run in real-time, but the scenario parameter <i>stepDuration</i> (for specifying the real duration of a simulation step) can be set to a suitable value for making the simulation observable in real-time.</p></section></section><section class="role-section1" id="SimModels"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</h2><section><h4>2.2.1. Model Variables and Functions</h4><p>In the simple model of a service desk discussed in the previous section, we define one (global) model variable, <i>queueLength</i>, one model function, <i>serviceDuration</i>(), and two event types, as shown in the following class diagram: </p><figure><img alt="???" src="IntroTutorial_files/IDM0.svg" width="360" /></figure><p>Notice that this model does not define any object type, which implies that the system state does not consist of any object, but only of one model variable, <span class="italic"><i>queueLength</i></span>. The discrete random variable for modeling random service durations is implemented as a model function <code>serviceDuration</code> shown in the <i>Model Variables and Functions</i> class. It samples integers between 2 and 4 from the empirical probability distribution <i>Emp{2:0.3, 3:0.5, 4:0.2}</i>. The model can be coded with OESjs in the following way:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">// (global) model variable
sim.model.v.<strong>queueLength</strong> = {
  range:&quot;NonNegativeInteger&quot;, 
  label:&quot;Queue length&quot;, 
  shortLabel:&quot;qLen&quot;, 
  initialValue: 0
};
// (global) model function
sim.model.f.<strong>serviceDuration</strong> = function () {
  return rand.frequency({&quot;2&quot;:0.3, &quot;3&quot;:0.5, &quot;4&quot;:0.2});
};</pre></td></tr></tbody></table><p>When a model variable, like <code>sim.model.v.queueLength</code>, is defined, its value can be accessed at simulation runtime with the expression <code>sim.v.queueLength</code>. A variable is shown in the user interface for model variables, whenever a <code>label</code> is defined for it. By default, the size of the variable's input field is 7. It can be changed by setting the property <code>inputFieldSize</code> in the variable definition.</p>A variable's value is shown in the simulation log, whenever a <code>shortLabel</code> is defined for it. <p>You can <a href="https://sim4edu.com/sims/14" target="_top">run this simulation model</a> and <a href="https://sim4edu.com/sims/14/Download.zip" target="_top">download its code</a> from the sim4edu.com website.</p></section><section><h4>2.2.2. Object Types</h4><p>Object types are defined in the form of classes. More precisely, they are defined as instances of the meta-class <i>cLASS</i>. Consider the object type <i>ServiceDesk</i> defined in the following model: </p><figure><img alt="???" src="IntroTutorial_files/IDM1.svg" width="400" /></figure><p>The object type <i>ServiceDesk</i> is defined with an attribute <code>queueLength</code>:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <strong>ServiceDesk</strong> = new cLASS({
  Name: &quot;ServiceDesk&quot;,
  label: &quot;Service desks&quot;,
  supertypeName: &quot;oBJECT&quot;,
  properties: {
    &quot;<strong>queueLength</strong>&quot;: { range: &quot;NonNegativeInteger&quot;, 
        label: &quot;Queue length&quot;, shortLabel: &quot;qlen&quot;}
  }
});</pre></td></tr></tbody></table><p>Notice that, in OESjs, object types are defined as subtypes of the pre-defined class <code>oBJECT</code>, from which they inherit an integer-valued <code>id</code> attribute and an optional <code>name</code> attribute. A property may have both a <code>label</code> and a <code>shortLabel</code>. The <code>label</code> is used for user interface fields, while the <code>shortLabel</code> is used in the simulation log, which only logs those objects and properties that do have a <i>shortLabel</i>.</p><p>The discrete random variable for modeling random service durations, which samples integers between 2 and 4 from the empirical probability distribution <i>Emp{2:0.3, 3:0.5, 4:0.2}</i>, is implemented as a class-level (&quot;static&quot;) function <code>serviceDuration</code> in the <i>ServiceDesk</i> class:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">ServiceDesk.<strong>serviceDuration</strong> = function () {
  return rand.frequency({&quot;2&quot;:0.3, &quot;3&quot;:0.5, &quot;4&quot;:0.2});
};</pre></td></tr></tbody></table><p>You can <a href="https://sim4edu.com/sims/1" target="_top">run this simulation model</a> and <a href="https://sim4edu.com/sims/1/Download.zip" target="_top">download its code</a> from the sim4edu.com website.</p></section><section><h4>2.2.3. Event Types</h4><p>We distinguish between two kinds of events:</p><ol><li><em>caused</em> events are caused by other events occurring during a simulation run;</li><li><em>exogenous</em> events seem to happen spontaneously, but may be caused by factors, which are external to the simulation model.</li></ol><p>Here is an example of an exogenous event type definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <strong>CustomerArrival</strong> = new cLASS({
  Name: &quot;CustomerArrival&quot;,
  label: &quot;Customer arrivals&quot;,
  shortLabel: &quot;Arr&quot;,  // for the log
  supertypeName: &quot;eVENT&quot;,
  <strong>properties</strong>: {
    &quot;serviceDesk&quot;: {range: &quot;ServiceDesk&quot;, label:&quot;Service desk&quot;}
  },
  <strong>methods</strong>: {
    &quot;onEvent&quot;: function () {
      ...
    }
  }
});</pre></td></tr></tbody></table><p>Notice that this event type definition includes a reference property <i>serviceDesk</i>, which is used for referencing the service desk object at which an event occurs. In OESjs, event types are defined as subtypes of the pre-defined class <code>eVENT</code>, from which they inherit an attribute <code>occTime</code>, which holds the occurrence time<a class="role-index-anchor" id="SimModels__I__6"></a> of an event. As opposed to objects, events do normally not have an ID, nor a name. </p><p>Each event type needs to define an <i>onEvent</i> method that implements the event rule for events of the defined type. Event rules are discussed below. Exogenous events occur periodically. They are therefore defined with a <em>recurrence</em> function,<a class="role-index-anchor" id="SimModels__I__7"></a> which provides the time in-between two events (often in the form of a random variable). The recurrence function is defined as a class-level method:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">CustomerArrival.<strong>recurrence</strong> = function () {
  return rand.uniformInt( 1, 6); 
};</pre></td></tr></tbody></table><p>Notice that the <i>recurrence</i> method of <i>CustomerArrival</i> is coded with the library method <code class="code">rand.uniformInt</code>, which allows sampling discrete uniform probability distribution functions (the <code class="code">rand</code> library provides several other PDF sampling methods as explained below). The OESjs simulator automatically creates the next <i>CustomerArrival</i> event by invoking the <i>recurrence</i> function for setting its <i>ocurrenceTime</i> and by copying all participant references (such as the <i>serviceDesk</i> reference). Only if an exogenous event<a class="role-index-anchor" id="SimModels__I__8"></a> type has additional properties, a <i>createNextEvent</i> method has to be defined for assigning all properties and returning the next event of that type. Whenever the simulator finds such a method, it will be invoked for creating corresponding exogenous events.</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <strong>CustomerDeparture</strong> = new cLASS({
  Name: &quot;CustomerDeparture&quot;,
  label: &quot;Customer departures&quot;,
  shortLabel: &quot;Dep&quot;,  // for the log
  supertypeName: &quot;eVENT&quot;,
  properties: {
    &quot;serviceTime&quot;: {range: &quot;NonNegativeInteger&quot;},
    &quot;serviceDesk&quot;: {range: &quot;ServiceDesk&quot;, label:&quot;Service desk&quot;}
  },
  methods: {
    &quot;onEvent&quot;: function () {
      ...
  }
});</pre></td></tr></tbody></table></section><section><h4>2.2.4. Event Rules</h4><p>An event rule<a class="role-index-anchor" id="SimModels__I__9"></a> for an event type defines what happens when an event of that type occurs, by specifying the caused state changes and follow-up events. In OESjs, an event rule for an event type is defined as a method <code>onEvent</code> of the class that implements the event type. This method, which is also called <i>event routine</i>,<a class="role-index-anchor" id="SimModels__I__a"></a> returns a set of events (more precisely, a set of JS objects representing events).</p><p>The following event rule method is defined in the <code>CustomerArrival</code> class.</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">// CustomerArrival event rule
&quot;<b>onEvent</b>&quot;: function () {
  var srvTm=0, changes = [], events = [];
  this.serviceDesk.queueLength++;
  sim.stat.arrivedCustomers++;
  // if the service desk is not busy
  if (this.serviceDesk.queueLength === 1) {
    srvTm = ServiceDesk.serviceDuration();
    events.push( new CustomerDeparture({
      occTime: this.occTime + srvTm,
      serviceTime: srvTm,
      serviceDesk: this.serviceDesk
    }));
  }
  return events;
}</pre></td></tr></tbody></table><p>The context of this event rule method is the event that triggers the rule, that is, the variable <code>this</code> references a JS object that represents the triggering event. Thus, the expression <code>this.serviceDesk</code> refers to the service desk object associated with the current customer arrival event, and the statement <code>this.serviceDesk.queueLength++</code> increments the <i>queueLength</i> attribute of this service desk object (as an immediate state change).</p><p>The following event rule method is defined in the <code>CustomerDeparture</code> class. </p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">// CustomerDeparture event rule
&quot;<b>onEvent</b>&quot;: function () {
  var changes = [], events = [], srvTm=0;
  // remove customer from queue
  this.serviceDesk.queueLength--;
  // if there are still customers waiting
  if (this.serviceDesk.queueLength &gt; 0) {
    // start next service and schedule its end/departure
    srvTm = ServiceDesk.serviceDuration();
    events.push( new CustomerDeparture({
      occTime: this.occTime + srvTm,
      serviceTime: srvTm,
      serviceDesk: this.serviceDesk
    }));
  }
  sim.stat.departedCustomers++;
  sim.stat.totalServiceTime += this.serviceTime;
  return events;
}</pre></td></tr></tbody></table></section><section><h4>2.2.5. Event Priorities</h4><p>An OES model may imply the possibility of several events occurring at the same time. Consequently, a simulator (like OESjs) must be able to process simultaneous events.<a class="role-index-anchor" id="SimModels__I__b"></a> In particular, simulation models based on discrete time may create simulation states where two or more events occur at the same time, but the model's logic requires them to be processed in a certain order. Defining priorities for events of a certain type helps to control the processing order of simultaneous events.</p><p>Consider an example model based on discrete time with three exogenous event types <i>StartOfMonth</i>, <i>EachDay</i> and <i>EndOfMonth</i>, where the recurrence of StartOfMonth and EndOfMonth is 21, and the recurrence of EachDay is 1. In this example we want to control that on simulation time 1 + <i>i</i> * 21 both a StartOfMonth and an EachDay event occur simultaneously, but StartOfMonth should be processed before EachDay, and on simulation time 21 + <i>i</i> * 21 both an EndOfMonth and an EachDay event occur simultaneously, but EndOfMonth should be processed after EachDay. This can be achieved by defining a high priority, say 2, to StartOfMonth, a middle priority, say 1, to StartOfMonth, and a low priority, say 0, to EndOfMonth. </p><p>Event priorities are defined as class-level properties of event classes in the event type definition file. Thus, we would define in <kbd>StartOfMonth.js</kbd>:</p><pre>StartOfMonth.priority = 2;</pre><p>and in <kbd>EachDay.js</kbd>:</p><pre>EachDay.priority = 1;</pre><p>and finally in <kbd>EndOfMonth.js</kbd>:</p><pre>EndOfMonth.priority = 0;</pre></section><section><h4>2.2.6. Library Methods for Sampling Probability Distribution Functions</h4><p>Random variables<a class="role-index-anchor" id="SimModels__I__c"></a> are implemented as methods that sample specific <em>probability distribution functions (PDFs)</em>.<a class="role-index-anchor" id="SimModels__I__d"></a> Simulation frameworks typically provide a library of predefined parametrized PDF sampling methods, which can be used with one or several (possibly seeded) streams of <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_top">pseudo-random numbers</a>.</p><p>The OESjs simulator provides the following predefined parametrized PDF sampling methods:</p><table border="1"><thead><tr><td style="text-align:center;"><p><b>Probability Distribution Function</b></p></td><td style="text-align:center;"><p><b>OESjs Library Method</b></p></td><td style="text-align:center;"><p><b>Example</b></p></td></tr></thead><tbody><tr><td><p><a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_top">Uniform</a></p></td><td><p><span style="font-family:monospace;">uniform</span>( lowerBound, upperBound)</p></td><td><p><span style="font-family:monospace;">rand.uniform( 0.5, 1.5)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution" target="_top">Discrete Uniform</a></p></td><td><p><span style="font-family:monospace;">uniformInt</span>( lowerBound, upperBound)</p></td><td><p><span style="font-family:monospace;">rand.uniformInt( 1, 6)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Triangular</a></p></td><td><p><span style="font-family:monospace;">triangular</span>( lowerBound, upperBound, mode)</p></td><td><p><span style="font-family:monospace;">rand.triangular( 0.5, 1.5, 1.0)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Frequency</a></p></td><td><p><span style="font-family:monospace;">frequency</span>( frequencyMap)</p></td><td><p><span style="font-family:monospace;">rand.frequency({&quot;2&quot;:0.4, &quot;3&quot;:0.6})</span></p></td></tr><tr><td><p><a href="http://en.wikipedia.org/wiki/Exponential_distribution" target="_top">Exponential</a></p></td><td><p><span style="font-family:monospace;">exponential</span>( eventRate)</p></td><td><p><span style="font-family:monospace;">rand.exponential( 0.5)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Gamma_distribution" target="_top">Gamma</a></p></td><td><p><span style="font-family:monospace;">gamma</span>( shape, scale)</p></td><td><p><span style="font-family:monospace;">rand.gamma( 1.0, 2.0)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Normal_distribution" target="_top">Normal</a></p></td><td><p><span style="font-family:monospace;">normal</span>( mean, stdDev)</p></td><td><p><span style="font-family:monospace;">rand.normal( 1.5, 0.5)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Pareto_distribution" target="_top">Pareto</a></p></td><td><p><span style="font-family:monospace;">pareto</span>( shape)</p></td><td><p><span style="font-family:monospace;">rand.pareto( 2.0)</span></p></td></tr><tr><td><p><a href="https://en.wikipedia.org/wiki/Weibull_distribution" target="_top">Weibull</a></p></td><td><p><span style="font-family:monospace;">weibull</span>( scale, shape)</p></td><td><p><span style="font-family:monospace;">rand.weibull( 1, 0.5)</span></p></td></tr></tbody></table><p>The OESjs library <span style="font-family:monospace;"><kbd>rand.js</kbd></span> supports both unseeded and seeded random number streams.<a class="role-index-anchor" id="SimModels__I__e"></a> By default, its PDF sampling methods are based on an unseeded stream, using Marsagliaâs high-performance random number generator <a href="https://en.wikipedia.org/wiki/Xorshift" target="_top"><em>xorshift</em></a> that is built into the <span style="font-family:monospace;"><code>Math.random</code></span> function of modern JavaScript engines.</p><p>A seeded random number stream, based on the slower <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_top">Mersenne Twister</a> algorithm, can be obtained by setting the scenario parameter <code><span style="font-family:monospace;">sim.scenario.randomSeed</span></code> to a positive integer value.</p><p>Additional streams can be defined and used in the following way:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var stream1 = new Random( 1234);
var stream2 = new Random( 6789);
var service1Duration = stream1.exponential( 0.5);
var service2Duration = stream2.exponential( 1.5);</pre></td></tr></tbody></table><p><b>Warning</b>: Avoid using JavaScript's built-in <span style="font-family:monospace;"><code>Math.random</code></span> in simulation code. Always use <span style="font-family:monospace;"><code>rand.uniform</code></span>, or one of the other probability distribution functions from the <span style="font-family:monospace;"><em>rand</em></span> library described above, for generating random numbers.</p></section></section><section class="role-section1" id="SimScenarios"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</h2><p>For obtaining a complete executable simulation scenario, a simulation model has to be complemented with <em>simulation parameter settings</em> and an <em>initial system state</em>.</p><p>In general, we may have more than one simulation scenario for a simulation model. For instance, the same model could be used in two different scenarios with different initial states.</p><p>A <em>simulation scenario</em> consists of</p><ol><li>simulation parameter settings, such as setting a value for <span style="font-family:monospace;"><code>simulationEndTime</code></span> and <span style="font-family:monospace;"><code>randomSeed</code></span>,</li><li>a simulation model,</li><li>an initial state definition, and</li><li>optional user interface (UI) definitions of, e.g., a statistics UI and an observation (or visualization) UI.</li></ol><p>An empty template for a simulation scenario has the following structure:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">// ***** Simulation Parameters **************
sim.scenario.simulationEndTime = ...;
sim.scenario.randomSeed = ...;    // optional
// ***** Simulation Model *******************
sim.model.time = &quot;...&quot;;  // discrete or continuous
sim.model.timeIncrement = ...;   // optional
sim.model.timeUnit = &quot;...&quot;;  // optional (ms|s|m|h|D|W|M|Y)
sim.model.objectTypes = [...];
sim.model.eventTypes = [...];
// ***** Initial State **********************
sim.scenario.initialState.objects = {...};
sim.scenario.initialState.events = {...};
// ***** Ex-Post Statistics *****************
sim.model.statistics = {...};</pre></td></tr></tbody></table><p>We briefly discuss each group of scenario information items in the following sub-sections.</p><section><h4>2.3.1. Pre-Defined Simulation Parameters</h4><p>A few simulation parameters are predefined as attributes of the simulation scenario. The most important ones are:</p><ul><li><strong>simulationEndTime</strong> - this mandatory attribute defines the duration of a simulation run;</li><li><em>stepDuration</em> - an optional attribute for specifying a minimum execution-time duration (in milliseconds) for each simulation step. This can be used for slowing down simulation steps such that simulation runs can be observed.</li><li><em>randomSeed</em>: Setting this optional parameter to a positive integer allows to obtain a specific fixed random number sequence (generated by a <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_top">Mersenne Twister</a> random number generator). This can be used for performing simulation runs with the same (repeated) random number sequence, e.g., for testing a simulation model by checking if expected results are obtained.</li></ul></section><section><h4>2.3.2. Metadata</h4><p>Both the model and the scenario can be documented and described by providing various metadata in a separate <kbd>metadata.js</kbd> file: a <i>name</i>, a <i>title</i> and a <i>shortDescription</i>, as well as meta data like <i>creator</i>, a <i>created</i> date, a (last) <i>modified</i> date and a copyright <i>license</i>, like so</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.model.name = &quot;...&quot;;
sim.model.title = &quot;...&quot;;
sim.model.license = &quot;CC BY-NC&quot;;
sim.model.shortDescription = &quot;...&quot;;
sim.model.systemNarrative = &quot;...&quot;;</pre></td></tr></tbody></table><p>It is recommended to use an <em>Attribution Share-Alike</em> <a href="http://creativecommons.org/" target="_top">Creative Commons</a> license by specifying its abbreviated name &quot;CC BY-SA&quot; (or &quot;CC BY-NC&quot; for non-commercial use).</p><p>The mandatory model attribute <em>systemNarrative</em> has to be used for providing a brief description of the real system under investigation, as opposed to the solution-specific model description provided by <em>shortDescription</em>.</p></section><section id="SimScenarios__sectInitialState"><h4>2.3.3. Initial State</h4><p>Defining an initial state means:</p><ol><li>assigning initial values to global variables, if there are any;</li><li>defining which objects exist initially, and assigning initial values to their properties;</li><li>defining which events are scheduled initially.</li></ol><p>A scenario must include an initial state definition, which consists of a set of initial object definitions and a set of initial event definitions. An initial state object is defined as an entry in the map <span style="font-family:monospace;"><code>initialState.objects</code></span> such that the object's <span style="font-family:monospace;"><code>id</code></span> value is the map entry's key, and the map entry's value is a set of property-value slots, including a slot for the special attribute <span style="font-family:monospace;"><em>typeName</em></span> defining the object's type, as shown in the following example:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.<b>initialState.objects</b> = {
  &quot;1&quot;: {<b>typeName</b>:&quot;ServiceDesk&quot;, name:&quot;serviceDesk1&quot;, queueLength:0}
};</pre></td></tr></tbody></table><p>Notice that object IDs are positive integers, but when used as keys in a map, they are converted to strings.</p><p>An initial event is defined as an element of the array list <code><span style="font-family:monospace;">initialState.events</span></code> in the form of a set of property-value slots, including a slot for the special attribute <span style="font-family:monospace;"><i>typeName</i></span> defining the event's type, as shown in the following example:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.<b>initialState.events</b> = [
  {<b>typeName</b>: &quot;CustomerArrival&quot;, occTime:1, serviceDesk:1}
];</pre></td></tr></tbody></table><p>When initial events (or objects) are parametrized with the help of model variables, they can be defined by moving the <span style="font-family:monospace;"><code>sim.scenario.initialState.events</code></span> definition to the <span style="font-family:monospace;"><code>sim.scenario.setupInitialState</code></span> function because this function is executed after the model variables are assigned.</p></section></section><section class="role-section1" id="SimConfigurations"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.4</span>. </span>Simulation Configurations</h2><p>A simulation scenario can be configured with various types of visualizations and various user interfaces (UI):</p><ol><li>Turn on/off the simulation log by setting the configuration parameter <span style="font-family:monospace;"><code>sim.config.createLog</code></span> to true/false.</li><li>Suppress or show the initial state UI, which allows to inspect/modify the initial values of model variables and the initial state of objects.</li><li>Turn on/off visualization, if there is one, by setting the configuration parameter <i>visualize</i> to true/false.</li><li>Turn on/off user interaction, if there is one, by setting the configuration parameter <i>userInteractive</i> to true/false. Since user interaction requires visualization, it is also turned off when <span style="font-family:monospace;"><code>sim.config.visualize</code></span> is set to false.</li><li>Slow down a (standalone) scenario simulation run by setting the configuration parameter <i>stepDuration</i>, which defines the duration of a simulation step (in ms). This is typically used for being able to observe a simulation run.</li><li>Credit art work used in a visualization with the parameter <i>artworkCredits</i>.</li></ol><p>In the simulation definition file, we could have settings like the following:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.config.createLog = true;
sim.config.suppressInitialStateUI = true;
sim.config.visualize = true;
sim.config.userInteractive = false;
sim.config.stepDuration = 200;   // 200 ms observation time per step
sim.config.artworkCredits = &quot;Weather icons by https://icons8.com&quot;;</pre></td></tr></tbody></table></section><section class="role-section1" id="SimStatistics"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.5</span>. </span>Statistics</h2><p>In scientific and engineering simulation projects the main goal is getting estimates of the values of certain variables or performance indicators with the help of statistical methods. In educational simulations, statistics can be used for observing simulation runs and for learning the dynamics of a simulation model. </p><p>For collecting statistics, suitable <em>statistics variables</em> have to be defined. The following code defines statistics variables for the service desk model.</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.model.statistics = {
  &quot;arrivedCustomers&quot;: {range:&quot;NonNegativeInteger&quot;, label:&quot;Arrived customers&quot;},
  &quot;departedCustomers&quot;: {range:&quot;NonNegativeInteger&quot;, label:&quot;Departed customers&quot;},
  &quot;totalServiceTime&quot;: {range:&quot;NonNegativeInteger&quot;},
  &quot;serviceUtilization&quot;: {range:&quot;Decimal&quot;, label:&quot;Service utilization&quot;,
      computeOnlyAtEnd: true, decimalPlaces: 1, unit: &quot;%&quot;,
      expression: function () {
        return sim.stat.totalServiceTime / sim.time * 100
      }
  },
  &quot;maxQueueLength&quot;: {objectType:&quot;ServiceDesk&quot;, objectIdRef: 1,
      property:&quot;queueLength&quot;, aggregationFunction:&quot;max&quot;, label:&quot;Max. queue length&quot;},
  &quot;averageQueueLength&quot;: {objectType:&quot;ServiceDesk&quot;, objectIdRef: 1,
    property:&quot;queueLength&quot;, aggregationFunction:&quot;avg&quot;, label:&quot;Avg. queue length&quot;},
  &quot;queueLength&quot;: {objectType:&quot;ServiceDesk&quot;, objectIdRef: 1,
    property:&quot;queueLength&quot;, showTimeSeries: true, label:&quot;Queue length&quot;}
};</pre></td></tr></tbody></table><p>The first three statistics variables (<i>arrivedCustomers</i>, <i>departedCustomers</i> and <i>totalServiceTime</i>) are simple variables that are updated in event routines (<i>onEvent</i> methods).</p><p>The <i>serviceUtilization</i> variable is only computed at the end of a simulation run by evaluating the expression specified for it (dividing the total service time by the simulation time). In the case of the remaining three variables, the data source is the object property <code>queueLength</code> of the service desk object with id=1. For the variable <code>maxQueueLength</code> the built-in aggregation function <code>max</code> is applied to this data source, computing the maximum of all <i>queueLength</i> values, while for the variable <code>averageQueueLength</code> the aggregation function <code>avg</code> is applied. The last variable, <i>queueLength</i>, is defined for the purpose of getting a time series chart.</p><p>The statistics results are shown in a default view of the statistics output. It is an option to define a non-standard user interface for the statistics output.</p></section><section class="role-section1" id="SimExperiments"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.6</span>. </span>Simulation Experiments</h2><p>There are different types of simulation experiments. In a <em>simple experiment</em>, a simulation scenario is run repeatedly by defining a number of replications (iterations) for being able to compute average statistics.</p><p>In a <em>parameter variation experiment</em>, several variants of a simulation scenario (called <em>experiment scenarios</em>), are defined by defining value sets for certain model variables (the <em>experiment parameters</em>), such that a parameter variation experiment run consists of a set of experiment scenario runs, one for each combination of parameter values.</p><p>When running an experiment, the resulting statistics data are stored in a database, which allows looking them up later on or exporting them to data analysis tools (such as Microsoft Excel and RStudio)</p><section><h4>2.6.1. <em>Simple Experiments</em></h4><p>A simple experiment is defined with a <code>sim.experiment</code> record on top of a scenario by defining (1) the number of <em>replications</em> and (2) possibly a list of <em>seed values</em>, one for each replication. The following code shows an example of a simple experiment definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experiment.<b>replications</b> = 5;
sim.experiment.<b>seeds</b> = [1234, 2345, 3456, 4567, 5678];</pre></td></tr></tbody></table><p>Running this simple experiment means running the underlying scenario 5 times, each time with another random seed, as specified by the list of seeds. The resulting statistics is computed by averaging all statistics variables defined for the given model. </p><p>When no seeds are defined, the experiment is run with implicit random seeds using JavaScript's built-in random number generator, which implies that experiment runs are not reproducible.</p></section><section><h4>2.6.2. <em>Parameter Variation Experiments</em></h4><p>A parameter variation experiment is defined with (1) a number of <em>replications</em>, (2) a list of <em>seed values</em> (one for each replication), and (3) one or more experiment parameters. The following code shows an example of a parameter variation experiment definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experiment.replications = 5;
sim.experiment.seeds = [1234, 2345, 3456, 4567, 5678];
sim.experiment.<b>parameterDefs</b> = [
  {name:&quot;arrivalEventRate&quot;, values:[0.4, 0.5, 0.6]}
];</pre></td></tr></tbody></table><p>Notice that this experiment definition defines three experiment scenarios: the 1st one with a value of 0.4 for the model variable <i>arrivalEventRate</i>, the 2nd one with a value of 0.5 and the 3rd one with a value of 0.6. Running this parameter variation experiment means running each of the 3 experiment scenarios 5 times (each time with another random seed, as specified by the list of seeds). The resulting statistics, as shown in the following table, is computed by averaging all statistics variables defined for the given model. </p><table border="1" class="expStatistics" id="SimExperiments__simLogTbl"><thead><tr><th colspan="5">Experiment Log</th></tr><tr><th rowspan="2">Experiment scenario</th><th rowspan="2">Parameter values</th><th colspan="3">Statistics</th></tr><tr><th>Arrived customers</th><th>Departed customers</th><th>Time in system [min]</th></tr></thead><tbody id="SimExperiments__simLog"><tr><td>0</td><td>0.4</td><td>4,032</td><td>3,981</td><td>90.7</td></tr><tr><td>1</td><td>0.5</td><td>5,041</td><td>4,788</td><td>358.6</td></tr><tr><td>2</td><td>0.6</td><td>6,072</td><td>4,926</td><td>1,011.6</td></tr></tbody></table><p>An experiment parameter must have the same name as the model variable to which it refers. It defines a set of values for this model variable, either using a <code>values</code> field or a combination of a <code>startValue</code> and <code>endValue</code> field (and <code>stepSize</code> for a non-default increment value) as in the following example:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experiment.replications = 5;
sim.experiment.seeds = [1234, 2345, 3456, 4567, 5678];
sim.experiment.parameterDefs = [
  {name:&quot;arrivalEventRate&quot;, <b>startValue</b>:0.4, <b>endValue</b>:0.9)}
];</pre></td></tr></tbody></table><p>There are a few further settings for controlling the storage of experiment statistics. An experiment should have an <code>id</code> value and a <code>title</code>. In addition, it should have a sequence number relative to the simulation scenario for which it is defined. These settings are shown in the following code listing:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experiment.id = 1;
sim.experiment.title = &quot;Test&quot;;
sim.experiment.experimentNo = 1;  // sequence number relative to simulation scenario</pre></td></tr></tbody></table></section><section><h4>2.6.1. <em>Storage of Experiment Statistics Data</em></h4><p>An experiment's statistics data is stored in a browser-managed database using JavaScript's <em>IndexedDB</em> technology. The name of this database is the same as the name of the simulation model. It can be inspected with the help of the browser's developer tools, which are typically activated with the key combination [Shift]+[Ctrl]+[I]. For instance, in Google's Chrome browser, one has to go to Application/Storage/IndexedDB.</p><p>The experiment statistics database consists of three tables containing data about (1) experiment definitions, (2) experiment runs, and (3) experiment scenario runs, which can be exported to a CSV file. By default, the statistics data obtained from running all replications of an experiment scenario is stored in averaged form as one experiment scenario run record. </p><section><p>When the output statistics of each single experiment scenario run is to be stored (for later analysis), this can be achieved by setting the Boolean experiment attribute <code>storeEachExperimentScenarioRun</code> to <i>true</i>, as in</p><pre>sim.experiment.storeEachExperimentScenarioRun = true;</pre><p>When time series data is to be created and stored for certain statistics variables, this can be achieved by listing the names of the variables in the experiment attribute <code>timeSeriesStatisticsVariables</code>, as in</p><pre>sim.experiment.timeSeriesStatisticsVariables = [&quot;arrivedCustomers&quot;,&quot;departedCustomers&quot;];</pre></section></section></section><section class="role-section1" id="Animation"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.7</span>. </span>Animation</h2><p></p><p>Animation is important for educational simulations and games, but it can also be used as a general tool for testing, inspecting and validating simulations.</p><p>Simulation runs can be animated by <em>visualizing</em> objects and events, by <em>sonifying</em> events and by allowing human users to <em>interact</em> with the simulated world. OESjs allows adding the following user interfaces (UI) to a simulation model:</p><ol><li>An <strong>observation UI</strong> defines various kinds of visualizations (including 3D) for allowing the user to observe what is going on during a simulation run. Space models, objects and events can be visualized by defining a <em>view</em> for them. An <em>object view</em> is defined by a 2D shape (like a <em>rectangle</em> or a <em>polygon</em>) or a 3D shape (like a <em>cuboid</em> or a <em>mesh</em>). An <em>event view</em> consists of an animation defined in the form of a <em>Web Animation</em> (of one or more DOM elements using key frames). Events can also be <em>sonified</em> by attaching specific sounds to event occurrences in an event appearance definition.</li><li>A <strong>user interaction UI</strong> allows human users to interact with a running simulation by taking decisions on the values of decision variables or by taking actions that change the value of certain simulation variables.</li><li>A <strong>participation UI</strong> allows human users to participate in a multi-agent simulation scenario by receiving situational information and by performing in-world actions via the user interface. Any multi-agent simulation model can be turned into a user-interactive <em>participatory simulation</em> by adding a <em>participation model</em> and a corresponding UI.</li></ol><section><h4>2.7.1. Adding an Observation User Interface</h4><p>For being able to observe a simulation run, some form of visualization has to be defined. OESjs supports both the visualization of <em>spatial models</em> and of non-spatial models. In a visualization of a non-spatial model, such as the ServiceDesk-1 model, all object views have to be explicitly positioned in an observation canvas. Rich two-dimensional visualizations can be obtained by using the web technology of <em>Scalable Vector Graphics (SVG)</em> in the definition of the observation UI.</p><p>In the case of our <em>ServiceDesk-1</em> model, we may, for instance, visualize the service desk using either an image or simply a fixed-size rectangle, and its queue in the form of a growing and shrinking bar.</p><p>For defining an observation UI with SVG-based visualization, the following settings have to be made:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.observationUI.type = &quot;SVG&quot;;
sim.scenario.observationUI.canvas.width = 600;
sim.scenario.observationUI.canvas.height = 300;</pre></td></tr></tbody></table><p>Then we first define the fixed elements of the visualization, giving each one a name (here: &quot;desk&quot;) and defining an SVG shape with attributes and a CSS style:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.observationUI.<b>fixedElements</b> = {
  &quot;desk&quot;: {
    shapeName: &quot;rect&quot;,
    shapeAttributes: { x: 350, y: 200, width: 50, height: 30},
    style: &quot;fill:brown; stroke-width:0&quot;
  }
};</pre></td></tr></tbody></table><p>For learning more about SVG shapes and their attributes, see the book chapter <a href="http://svgpocketguide.com/book/#section-2" target="_top">Basic Shapes &amp; Paths</a> by Joni Trythall. For learning more about CSS styling of SVG elements, see <a href="http://www.smashingmagazine.com/2014/11/styling-and-animating-svgs-with-css/" target="_top">Styling And Animating SVGs With CSS</a> by Sara Soueidan.</p><p>The main issue in visualization is to map the state variables of interest to suitable visual parameters such as colors, shape size, etc. For instance, we may want to map the <i>queueLength</i> attribute to the width of a rectangle, as in the following object view definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.observationUI.<b>objectViews</b> = {
  &quot;serviceDesk1&quot;: [  // a view of the queue
    { shapeName: &quot;rect&quot;,  // a rectangle defined by 
      shapeAttributes: {  // left-upper corner (x,y) as well as width and height
        x: function (sd) {return Math.max( 0, 330 - sd.queueLength * 20);},
        width: function (sd) {return Math.min( 300, sd.queueLength * 20);},
        y: 150, height: 80
      },
      style:&quot;fill:yellow; stroke-width:0&quot;
    },
    { shapeName: &quot;text&quot;,
      shapeAttributes: {x: 325, y: 250,
          textContent: function (sd) {return sd.queueLength;}},
      style:&quot;font-size:14px; text-anchor:middle&quot;
    }
  ]
};</pre></td></tr></tbody></table></section></section><section class="role-section1" id="SimProgramming"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.8</span>. </span>Simulation Programming with OESjs</h2><section><h4>2.8.1. Using the Simulation Log</h4><p>The OESjs simulator can generate a simulation log, which allows to inspect the evolving states of a simulation run. Inspecting the simulation log can help to understand the dynamics of a model, or it can be used for finding logical flaws in it.</p><p>The contents of the simulation log can be controlled by defining <em>short labels</em> for those objects and object properties as well as event types that we want to see in the log, using the <span style="font-family:monospace;"><code>shortLabel</code></span> attribute. For instance, in the case of the <a href="https://sim4edu.com/sims/1" target="_top">service desk model</a>, defining the short labels &quot;sd1&quot; for the service desk object, &quot;qLen&quot; for the <span style="font-family:monospace;"><code>queueLength</code></span> property, &quot;Arr&quot; for the <span style="font-family:monospace;"><code>CustomerArrival</code></span> event type and &quot;Dep&quot; for the <span style="font-family:monospace;"><code>CustomerDeparture</code></span> event type leads to the following simulation log:</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td colspan="3" style="text-align:center;"><p><b>Simulation Log</b></p></td></tr><tr><td style="text-align:center;"><p><b>Time</b></p></td><td style="text-align:center;"><p><b>System State</b></p></td><td style="text-align:center;"><p><b>Future Events</b></p></td></tr></thead><tbody><tr><td><p>0</p></td><td><p>sd1{ qLen: 0}</p></td><td><p>Arr@1</p></td></tr><tr><td><p>1</p></td><td><p>sd1{ qLen: 1}</p></td><td><p>Arr@4, Dep@4</p></td></tr><tr><td><p>4</p></td><td><p>sd1{ qLen: 1}</p></td><td><p>Arr@5, Dep@8</p></td></tr><tr><td><p>5</p></td><td><p>sd1{ qLen: 2}</p></td><td><p>Dep@8, Arr@10</p></td></tr><tr><td><p>8</p></td><td><p>sd1{ qLen: 1}</p></td><td><p>Arr@10, Dep@12</p></td></tr><tr><td><p>10</p></td><td><p>sd1{ qLen: 2}</p></td><td><p>Dep@12, Arr@12</p></td></tr><tr><td><p>12</p></td><td><p>sd1{ qLen: 2}</p></td><td><p>Arr@15, Dep@16</p></td></tr><tr><td><p>15</p></td><td><p>sd1{ qLen: 3}</p></td><td><p>Dep@16, Arr@21</p></td></tr><tr><td><p>16</p></td><td><p>sd1{ qLen: 2}</p></td><td><p>Dep@18, Arr@21</p></td></tr><tr><td><p>18</p></td><td><p>sd1{ qLen: 1}</p></td><td><p>Dep@20, Arr@21</p></td></tr><tr><td><p>20</p></td><td><p>sd1{ qLen: 0}</p></td><td><p>Arr@21</p></td></tr></tbody></table></section><section><h4>2.823. Creating Objects and Events for the Initial State</h4><p>In <a href="#SimScenarios__sectInitialState"></a>, we have shown how to create initial objects for the initial state of a simulation scenario using the map <code>sim.scenario.initialState.objects</code>. Whenever the initial state has to be populated with a larger set of objects, we can define a set-up procedure <code>sim.scenario.setupInitialState</code>, as in the following example where we create 100 <code>ServiceDesk</code> objects, each with an associated <code>CustomerArrival</code> event: </p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.<b>setupInitialState</b> = function () {
  var i=1;
  for (i=1; i &lt;= 100; i++) {
    sim.addObject( new ServiceDesk({
      id: i,
      typeName: &quot;ServiceDesk&quot;,
      queueLength: 0
    }));
    sim.scheduleEvent( new CustomerArrival( {
      occTime: 1,
      serviceDesk: i
    }));
  }
};</pre></td></tr></tbody></table></section><section><h4>2.8.3. Accessing Objects</h4><p>The objects defined in the initial state, or created during a simulation run, can be accessed either by their ID number or by their name, if they have one. For instance, the object {typeName:&quot;ServiceDesk&quot;, id: 1, name:&quot;serviceDesk1&quot;, queueLength: 0} defined above, has the ID number 1 and the name &quot;serviceDesk1&quot;. It can be retrieved by ID from the simulator map <code>sim.objects</code> in the following way: </p><pre>var object1 = sim.objects[&quot;1&quot;];</pre><p>It can also be retrieved by name from the simulator map <code>sim.<b>namedObjects</b></code> in the following way:</p><pre>var object1 = sim.namedObjects[&quot;serviceDesk1&quot;];</pre><p>For looping over all simulation objects, we can loop over the simulator map <code>sim.objects</code> in the following way:</p><pre>Object.keys( sim.objects).forEach( function (objIdStr) {
  var obj = sim.objects[objIdStr];
  ...  // do something with obj
});</pre><p>We can loop over all simulation objects of a specific type, say <code>ServiceDesk</code>, in the following way:</p><pre>Object.keys( cLASS[&quot;ServiceDesk&quot;].instances).forEach( function (objIdStr) {
  var obj = cLASS[&quot;ServiceDesk&quot;].instances[objIdStr];
  ...  // do something with obj
});</pre><p>If a simulation has to deal with a large number of objects, using a <code>for</code> loop may be faster than a <code>forEach</code> loop.</p></section><section><h4>2.8.4. Defining and Using a History for an Attribute of an Object</h4><p>There are use cases which require to construct a history of the changing values of a certain attribute for a specific object and evaluate or simply display this history. For example, we may define a history for the attribute <code>queueLength</code> of service desks using the <code>historySize</code> parameter: </p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var ServiceDesk = new cLASS({
  Name: &quot;ServiceDesk&quot;,
  supertypeName: &quot;oBJECT&quot;,
  properties: {
    &quot;queueLength&quot;: { range: &quot;NonNegativeInteger&quot;, historySize: 7,
        label: &quot;Queue length&quot;, shortLabel: &quot;qlen&quot;}
  }
});

In such </pre></td></tr></tbody></table><p>In such a case, the OESjs simulator automatically constructs a history buffer of the specified size, which can, for instance, be converted to a string with the expression</p><pre>sim.namedObjects[&quot;serviceDesk1&quot;].history.queueLength.toString()</pre><p>A <em>history buffer</em> is a ring buffer, having a limited size and an <code>add</code> operation for adding new items to the buffer as in:</p><pre>sim.namedObjects[&quot;serviceDesk1&quot;].history.queueLength.add( this.queueLength);</pre><p>Notice that the oldest item may get lost when a (fixed-size) buffer is already full and a new item is added.</p><pre>Object.keys( cLASS[&quot;ServiceDesk&quot;].instances).forEach( function (objIdStr) {
  var obj = cLASS[&quot;ServiceDesk&quot;].instances[objIdStr];
  ...  // do something with obj
});</pre><p>If a simulation has to deal with a large number of objects, using a <code>for</code> loop may be faster than a <code>forEach</code> loop.</p></section></section></section><div class="role-backmatter" id="backmatter"><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1><nav class="role-index-toc" id="__I_TOC"><span class="role-index-toc-placeholder">A</span> <span class="role-index-toc-placeholder">B</span> <span class="role-index-toc-placeholder">C</span> <a class="role-index-div-ref" href="#__I_TOC_D">D</a> <a class="role-index-div-ref" href="#__I_TOC_E">E</a> <span class="role-index-toc-placeholder">F</span> <span class="role-index-toc-placeholder">G</span> <span class="role-index-toc-placeholder">H</span> <span class="role-index-toc-placeholder">I</span> <span class="role-index-toc-placeholder">J</span> <span class="role-index-toc-placeholder">K</span> <span class="role-index-toc-placeholder">L</span> <span class="role-index-toc-placeholder">M</span> <span class="role-index-toc-placeholder">N</span> <a class="role-index-div-ref" href="#__I_TOC_O">O</a> <a class="role-index-div-ref" href="#__I_TOC_P">P</a> <span class="role-index-toc-placeholder">Q</span> <a class="role-index-div-ref" href="#__I_TOC_R">R</a> <a class="role-index-div-ref" href="#__I_TOC_S">S</a> <span class="role-index-toc-placeholder">T</span> <span class="role-index-toc-placeholder">U</span> <span class="role-index-toc-placeholder">V</span> <span class="role-index-toc-placeholder">W</span> <span class="role-index-toc-placeholder">X</span> <span class="role-index-toc-placeholder">Y</span> <span class="role-index-toc-placeholder">Z</span></nav><div class="role-index-div" id="__I_TOC_D"><h2 class="role-index-div-title">D<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I2"><span class="role-index-term">discrete dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__2">1</a></span></li><li class="role-index-entry" id="__I1"><span class="role-index-term">discrete event system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__1">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_E"><h2 class="role-index-div-title">E<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I8"><span class="role-index-term">event routine</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__a">1</a></span></li><li class="role-index-entry" id="__I7"><span class="role-index-term">event rule</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__9">1</a></span></li><li class="role-index-entry" id="__I3"><span class="role-index-term">exogenous event</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__3">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__8">2</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_O"><h2 class="role-index-div-title">O<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I6"><span class="role-index-term">occurrence time</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__6">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_P"><h2 class="role-index-div-title">P<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ia"><span class="role-index-term">probability distribution function</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__d">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_R"><h2 class="role-index-div-title">R<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ib"><span class="role-index-term">random number stream</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__e">1</a></span></li><li class="role-index-entry" id="__I5"><span class="role-index-term">random variable</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__5">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__c">2</a></span></li><li class="role-index-entry" id="__I4"><span class="role-index-term">recurrence</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__4">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__7">2</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_S"><h2 class="role-index-div-title">S<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I9"><span class="role-index-term">simultaneous events</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__b">1</a></span></li></ul></div></section></div></section></body></html>